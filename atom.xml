<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cannoneyed.github.io/</id>
    <title>cannoneyed</title>
    <updated>2017-05-15T00:56:17Z</updated>
    <author>
        <name>Andy Coenen</name>
        <email>andrew.coenen@gmail.com</email>
        <uri>https://cannoneyed.github.io/about</uri>
    </author>
    <link rel="alternate" href="https://cannoneyed.github.io"/>
    <subtitle>Andy Coenen - Software developer and artist living and working in San Francisco.</subtitle>
    <rights>All rights reserved  2017, Siddharth Jain</rights>
    <generator>Feed for Node.js</generator>
    <entry>
        <title type="html"><![CDATA[OSC and the future of signaling]]></title>
        <id>https://cannoneyed.github.io/blog/2015-01-02-osc-future-signaling/</id>
        <link href="https://cannoneyed.github.io/blog/2015-01-02-osc-future-signaling/">
        </link>
        <updated>2015-01-02T08:00:00Z</updated>
        <summary type="html"><![CDATA[A new signaling protocol for new means of expression]]></summary>
        <content type="html"><![CDATA[<figure class="full-width"><img src="https://cannoneyed.github.io/blog/2015-01-02-osc-future-signaling/max-ableton.jpg" alt=""></figure>
<p>The most consistent challenge I&#x2019;ve encountered in my decade of exploring interactive media has been how to get information from point A to point B in a way that fosters creativity. Turning a knob and seeing or hearing a program react is amazing, but true expressivity comes from a careful attention to the &#x2018;physics&#x2019; of the interaction. Like playing a finely crafted instrument, creativity and expressivity is dependent on the nuance, subtlety, and reactivity provided by great tool design.</p>
<hr>
<p>Media artists have been empowered by a relatively recent explosion of creative technologies - Ableton Live revolutionized digital audio performance and, partnered with programs like Max/MSP, Touch Designer, and Resolume Avenue, can serve as a hub for a complete multimedia experience. But at its core, the signaling architecture most commonly used by these programs remains unchanged since its inception in the 80&#x2019;s.</p>
<p>MIDI is a remarkably robust technology - standardized in 1983, its current ubiquity is testament to that fact. But with everyday computing power many orders of magnitude greater today and an almost limitless toolkit available to creative technologists, MIDI&#x2019;s age is showing more and more. HD video sequencing, realtime 3D composition and rendering, drone control, robotic interfacing, augmented reality, and anything imaginable can be controlled from pretty much anything&#x2026; But if you want to run these things from a sequencer or most hardware controllers you&#x2019;ll still have to translate from a MIDI signal - which is limited to 7 bits (0-127) of data and has no semantic metadata.</p>
<p>Enter OSC - a protocol first outlined by the CNMAT at UC Berkeley. OSC allows transmission of URL-encoded data at high data and time resolution over UDP (or TCP, with a bit of work). This means that any part of any system can be given a lexical OSC address to receive signals from anywhere else without complex encoding schemes or limits on data resolution, internally or over a network. For example, triggering the first video clip of the first layer in Resolume Avenue is as simple as sending the message <code>/layer1/clip1/connect 1</code> to whatever port Resolume is listening to, rather than a numbered MIDI mapping.</p>
<figure>
    <img src="https://cannoneyed.github.io/blog/2015-01-02-osc-future-signaling/touch-osc.png" alt="">
    <figcaption><a href="http://hexler.net/software/touchosc" title="TouchOSC Interface enabling iPad control">TouchOSC Interface enabling iPad control</a>.</figcaption>
</figure>
<p>It&#x2019;s in complex sets of high-resolution data where OSC can really shine - Large banks of lights, incredibly precise inverse kinematic controls for robotics, 3D generative content, or data from human-interfacing devices can all be routed and parsed incredibly quickly and easily - The expressivity and depth and breadth of control that creativity requires is much more readily achieved.</p>
<p>In order for OSC to achieve mainstream acceptance, a major change in the toolkits of creative multimedia artists is required. Ableton Live is currently the de facto standard for central dispatching of many multimedia projects, yet currently has no packaged support for OSC. There&#x2019;s a huge hole in the marketplace waiting to be filled by whatever&#x2019;s up to the task.</p>
<hr>
<p>One of my first big programming projects was a simple OSC audio unit plugin that I worked on before starting all of the precourse work required for Hack Reactor. I used it to great effect to design and produce The M Machine&#x2019;s video content for their recent tour with The Glitch Mob, to great effect. I was able to control video in Resolume at sub-frame precision from the Logic timeline, and instantiate and modify video effects and real-time generated Quartz Composer content all from the DAW. It&#x2019;s been an exciting project, and I look forward to releasing a finished version soon.</p>
]]></content>
        <author>
            <name>Andy Coenen</name>
            <email>andrew.coenen@gmail.com</email>
            <uri>https://cannoneyed.github.io/about</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[N queens in a tweet]]></title>
        <id>https://cannoneyed.github.io/blog/2015-01-03-n-queens-in-a-tweet/</id>
        <link href="https://cannoneyed.github.io/blog/2015-01-03-n-queens-in-a-tweet/">
        </link>
        <updated>2015-01-03T08:00:00Z</updated>
        <summary type="html"><![CDATA[A lot of power in a little bit of space]]></summary>
        <content type="html"><![CDATA[<p>One of the most interesting sprints of the first two weeks at Hack Reactor involved the famous n-queens problem: given a chessboard of size n x n, how many ways can you arrange n queens on the boards such that no queen is threatened by another?</p>
<p>My partner <a href="https://github.com/zdlopez" title="github">Zachary Lopez</a> and I created a few different algorithms to approach this problem, ultimately implementing a bitwise solution described <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.51.7113&amp;rep=rep1&amp;type=pdf" title="Backtracking Algorithms in MCPL using Bit Patterns and Recursion">here</a>. The bitwise algorithm represented a nearly twenty-fold increase in efficiency over our algorithm. Searching to eke out even more speed, we set up a system of web workers with <a href="http://adambom.github.io/parallel.js/" title="parallel.js">parallel.js</a> to split processing onto multiple cores of our machine, and, of course, minified our algorithm to fit into a tweet.</p>
<pre><code class="language-javascript">function q(n){x=0,a=(1&lt;&lt;n)-1;
function i(l,c,r){if(c==a)x++;
var p=~(l|c|r)&amp;a,b;
for(;p;p-=b){b=p&amp;-p;i((l|b)&lt;&lt;1,c|b,(r|b)&gt;&gt;1)}}i();
return x}
</code></pre>
<p><em>137 characters without newlines added for clarity</em></p>
]]></content>
        <author>
            <name>Andy Coenen</name>
            <email>andrew.coenen@gmail.com</email>
            <uri>https://cannoneyed.github.io/about</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Console injector]]></title>
        <id>https://cannoneyed.github.io/blog/2015-01-15-console-injector/</id>
        <link href="https://cannoneyed.github.io/blog/2015-01-15-console-injector/">
        </link>
        <updated>2015-01-15T08:00:00Z</updated>
        <summary type="html"><![CDATA[A chrome extension for quickly injecting javascript libraries from the console]]></summary>
        <content type="html"><![CDATA[<p>Last Thursday night we were given the opportunity to participate in a two-hour hackathon here at Hack Reactor, and when we were presented with the prompt of making a chrome extension, an idea I&#x2019;d been thinking about in prior weeks immediately sprung to mind. Wouldn&#x2019;t it be great to be able to quickly inject javascript libraries right from the console?</p>
<p>My partner during the D3 sprint (<a href="https://github.com/mmconrad" title="github">Matt Conrad</a>) and I had talked about how cool this would be when we were initially exploring the library. Instead of creating a custom &#x2018;demo&#x2019; and manually installing the libraries, it would be very handy to quickly inject a library of choice into any page right from the console and get coding.</p>
<p>Enter <a href="https://github.com/cannoneyed/console-injector">Console Injector</a>! The chrome extension creates a console.inject method that can be called to quickly inject any javascript library onto a given page.</p>
<pre><code>console.inject(&apos;jquery&apos;)
</code></pre>
<p>The method searches <a href="https://cdnjs.com/">cdnjs</a> for javascript libraries matching a given input string, and inserts the latest corresponding script hosted at <a href="http://cdnjs.cloudflare.com">cdnjs.cloudflare.com</a>. The magic lies in the following snippet of code, which &#x2018;injects&#x2019; an injector script into the head of the current document:</p>
<pre><code class="language-javascript">var element = document.createElement(&apos;script&apos;);
element.innerHTML = &apos;console.inject = &apos; + injectFunction.toString();
document.head.appendChild(element);
</code></pre>
<p>Since the javascript executed in the chrome extension doesn&#x2019;t have access to any variables in the current page, in order to modify the console object (which is just another object) we must first append a script to the DOM, which then modifies the console object indirectly. This bit of redirection allows us to inject an injector script onto the page, which in turn generates more script tags with a source attribute corresponding to the queried library.</p>
<hr>
<p>Console Injector was a great project to learn about Chrome extensions and bring something to life in a short amount of time. I&#x2019;d like to give a big thanks to all of my team members: <a href="http://www.github.com/wesleysmyth">Wesley Smyth</a>, <a href="http://www.github.com/kranrao">Kiran Rao</a>, <a href="http://www.github.com/henryw4k">Henry Wong</a>, and <a href="http://www.github.com/mmconrad">Matt Conrad</a>.</p>
<p>Console Injector is <a href="https://github.com/cannoneyed/console-injector">open source</a> and available to download on the <a href="https://chrome.google.com/webstore/detail/abdfbnapkafgcheofcijaieahcbjnpkd">Google Chrome Web Store</a>.</p>
]]></content>
        <author>
            <name>Andy Coenen</name>
            <email>andrew.coenen@gmail.com</email>
            <uri>https://cannoneyed.github.io/about</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[GeoJSON Queries in MongoDB]]></title>
        <id>https://cannoneyed.github.io/blog/2015-02-05-geojson-query-mongodb/</id>
        <link href="https://cannoneyed.github.io/blog/2015-02-05-geojson-query-mongodb/">
        </link>
        <updated>2015-02-05T08:00:00Z</updated>
        <summary type="html"><![CDATA[Location based querying across dimensions]]></summary>
        <content type="html"><![CDATA[<p>MongoDB has gained a lot of momentum over the last few years by presenting itself as a more versatile and free form database alternative to the highly structured, schema-based standards like mySQL. However mongo offers a number of incredibly powerful query abilities that rely on setting up a more rigid set of indices, including robust geographic search capabilities based on geoJSON.</p>
<p>GeoJSON is a format for encoding a variety of geographic features in a specific way.</p>
<pre><code class="language-javascript">{
  &quot;type&quot;: &quot;Feature&quot;,
  &quot;geometry&quot;: {
    &quot;type&quot;: &quot;Point&quot;,
    &quot;coordinates&quot;: [-122.409046, 37.783748]
  },
  &quot;properties&quot;: {
    &quot;name&quot;: &quot;Hack Reactor&quot;
  }
}
</code></pre>
<p>The first thing to note is that geoJSON encodes the coordinates of a feature as an array pair of [longitude, latitude], which is the opposite of many popular georgraphic services (like the Google Maps API) which returns latitude / longitude pairs. The second point of interest is that a geoJSON object can contain a variety of geometries. This example represents a single point, but any polygon or shape can be represented.</p>
<p>In order to query mongoDB based on geoJSON objects, the data in the database must be indexed geographically. This allows mongo to look up geographic data by a geographic query very efficiently. It&#x2019;s as simple as setting up an index, which can be done using mongoose:</p>
<pre><code class="language-javascript">var mongoose = require(&apos;mongoose&apos;);

var LocationSchema = new mongoose.Schema({
  location : {
    type: {
      type: String,
      default: &apos;Point&apos;
    },
    coordinates: [Number]
  }
});

LocationSchema.index({ location : &apos;2dsphere&apos; });

Location = mongoose.model(&apos;Location&apos;, LocationSchema);
</code></pre>
<p>This sets up a simple schema of a location object encoded in geoJSON based format. By indexing the location object to type &#x2018;2dsphere&#x2019;, mongo can very efficiently query this set of data based on passed in geoJSON queries.</p>
<pre><code class="language-javascript">query.location = {
  $near : {
    $geometry : {
      type : &quot;Point&quot;,
      coordinates : [-122.409046, 37.783748]
    },
    $maxDistance : 1000
  }
}

Location.find(query);
</code></pre>
<p>One of the most powerful features that the geoJSON querying format allows for is using complex geometries to query the database. The example above simply searches for all points within a radius of 1000 meters, but by using a complex polygonal geometry as the query geometry, mongo can search within any imaginable bounding object, for instance all of the points within a few blocks of a given route.</p>
]]></content>
        <author>
            <name>Andy Coenen</name>
            <email>andrew.coenen@gmail.com</email>
            <uri>https://cannoneyed.github.io/about</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Generator functions with promises]]></title>
        <id>https://cannoneyed.github.io/blog/2016-01-18-generator-functions-with-promises/</id>
        <link href="https://cannoneyed.github.io/blog/2016-01-18-generator-functions-with-promises/">
        </link>
        <updated>2016-01-18T08:00:00Z</updated>
        <summary type="html"><![CDATA[An in-depth explanation of how generator functions can be used to make complex asynchronous code simple]]></summary>
        <content type="html"><![CDATA[<p>A <strong>generator function</strong> is a function that can be exited and re-entered later. It&#x2019;s written just like a normal function, except it&#x2019;s declared with the keyword <code>function*</code>. Notice the <code>yield</code> keywords, which can only be used inside a <strong>generator function</strong> - these are the points where code execution enters and exits the function body.</p>
<pre><code class="language-javascript">var sayHello = (what) =&gt; `hello, ${what}`

function* generator() {
  yield sayHello(&apos;dog&apos;)
  yield sayHello(&apos;cat&apos;)
}
</code></pre>
<p>Invoking a <strong>generator function</strong> creates an <strong>iterator</strong>.</p>
<pre><code class="language-javascript">var iterator = generator()
</code></pre>
<p>Iterators provide the interface for running the code inside of a generator function. By invoking the <code>next</code> method of the iterator, we can run code in the generator function in steps, with program flow entering and exiting the function body.</p>
<pre><code class="language-javascript">var message = iterator.next().value
// message = &apos;hello, dog&apos;
message = iterator.next().value
// message = &apos;hello, cat&apos;
</code></pre>
<p>When <code>iterator.next()</code> is invoked, the code inside of <code>generator</code> is executed up to the first <code>yield</code> statement, where the code &#x2018;pauses&#x2019;. The result of invoking <code>iterator.next()</code> is a <code>step</code> object with a <code>value</code> property, which is the value of the expression to the right of the <code>yield</code> keyword (<code>sayHello(&apos;dog&apos;)</code>, which returned <code>&apos;hello, dog&apos;</code>). Invoking <code>iterator.next()</code> again &#x2018;resumes&#x2019; program flow where it left off and executes until the next yield statement. The <code>step</code> object returned by <code>next()</code> now has a <code>value</code> of <code>&apos;hello, cat&apos;</code>.</p>
<p>This <code>step</code> object returned by invoking <code>next</code> contains another property: <code>done</code>. The <code>done</code> property is a<code>boolean</code> and is only <code>true</code> after the <strong>generator function</strong> returns.</p>
<pre><code class="language-javascript">const saySomething = (what) =&gt; `hello, ${what}`

function* generator() {
  yield saySomething(&apos;dog&apos;)
  yield saySomething(&apos;cat&apos;)
  return &apos;fin&apos;
}

var iterator = generator()
var step = iterator.next() // { value: &apos;hello, dog&apos;, done: false }
step = iterator.next() // { value: &apos;hello, cat&apos;, done: false }
step = iterator.next() // { value: &apos;fin&apos;, done: true }

</code></pre>
<p>We can also pass input back into the generator function by invoking the <code>next</code> method with an argument. The value passed into the <code>next</code> method is assigned to the left of the <code>yield</code> keyword. This behavior is illustrated below.</p>
<pre><code class="language-javascript">// All together
const saySomething = (what) =&gt; `hello, ${what}`

function* generator() {
  var response = yield saySomething(&apos;dog&apos;)
  console.log(response)
  response = yield saySomething(&apos;cat&apos;)
  console.log(response)
}

var iterator = generator()

var message
message = iterator.next(1).value
console.log(message)
message = iterator.next(2).value
console.log(message)
// hello, dog
// 1
// hello, cat
// 2
</code></pre>
<hr>
<p>This functionality is very interesting - exiting and re-entering a function body is certainly some unique behavior. As it turns out, it&#x2019;s a very useful trick in handling asynchronous code.</p>
<p>By leveraging <strong>generator functions</strong> with some clever use of <strong>Promises</strong>, we can create an elegant way to handle complex asynchronous code in a simple, readable way.</p>
<p>Let&#x2019;s begin by imagining that our <code>sayHello</code> function needed to do some asynchronous work that takes some time and returns a <strong>Promise</strong>. The normal <strong>Promise</strong>-based control flow would look something like this:</p>
<pre><code class="language-javascript">var Promise = require(&apos;bluebird&apos;)
var sayHello = (what) =&gt; Promise.resolve(`hello, ${what}`).delay(1000)

function usePromises () {
  return sayHello(&apos;dog&apos;)
    .then(message =&gt; {
      console.log(message)
      return sayHello(&apos;cat&apos;)
    })
    .then(message =&gt; {
      console.log(message)
    })
}

usePromises()
// 0s: &apos;hello, dog&apos;
// 1s: &apos;hello, cat&apos;
</code></pre>
<p>This chainable <code>.then</code> style syntax, especially when complemented with <code>bluebird</code>&apos;s excellent helper methods, is certainly an improvement over a raw callback-based approach and libraries such as <code>async</code>, but it leaves a lot to be desired, especially when things get complicated and fairly nested <strong>Promise</strong> chain logic becomes unavoidable.</p>
<p>If we could use the es7 <code>async</code> / <code>await</code> syntax, this code would be much more elegant. However, these methods are not part of the es6 standard and require a transpilation step, which is not for everyone. Here&#x2019;s what the future holds:</p>
<pre><code class="language-javascript">var Promise = require(&apos;bluebird&apos;)
var sayHello = (what) =&gt; Promise.resolve(`hello, ${what}`).delay(1000)

async function useAsyncAwait() {
  var message = await sayHello(&apos;dog&apos;)
  console.log(message)
  message = await sayHello(&apos;cat&apos;)
  console.log(message)
}

useAsyncAwait()
// 1s: &apos;hello, dog&apos;
// 2s: &apos;hello, cat&apos;
</code></pre>
<p>The <code>async</code> / <code>await</code> syntax is remarkably simple to our <strong>generator function</strong> based code from earlier - execution of code seemingly pauses in the middle of the function, waits for a <strong>Promise</strong> to resolve, then picks up where it left off. The question is, can we make <strong>generator functions</strong>  exhibit the same sort of behavior with asynchronous code?</p>
<p>It turns out that we can by using a few tricks. <code>bluebird</code>, as usual, offers an excellent implementation, but to better understand how it works and feel even more confident in our understanding, we&#x2019;ll build our own.</p>
<p>Recall that a <strong>generator function</strong> returns an <strong>iterator</strong>, and that this <strong>iterator</strong> is the interface for running the code inside of the generator. Also recall that by invoking the <strong>iterator</strong>&#x2019;s <code>next</code> method, code inside the generator is executed up to the <code>yield</code> statement, where it &#x2018;pauses&#x2019; until the <code>next</code> method is invoked again.</p>
<p>Now imagine pairing our asynchronous <code>sayHello</code> function with a <strong>generator function</strong>, like below</p>
<pre><code class="language-javascript">var Promise = require(&apos;bluebird&apos;)
var sayHello = (what) =&gt; Promise.resolve(`hello, ${what}`).delay(1000)

function* generator() {
  yield sayHello(&apos;dog&apos;)
  yield sayHello(&apos;cat&apos;)
}
</code></pre>
<p>If we create an <strong>iterator</strong> and invoke <code>next</code>, it should come as no surprise that the <code>value</code> property of the object returned by calling the <strong>iterator</strong>&#x2019;s <code>next</code> method is a <strong>Promise</strong>, since that&#x2019;s what <code>sayHello</code> is returning.</p>
<pre><code class="language-javascript">var message
message = iterator.next().value
// message = Promise (will eventually resolve &apos;hello, dog&apos;)
message = iterator.next().value
// message = Promise (will eventually resolve &apos;hello, cat&apos;)
</code></pre>
<p>This is the secret - Since each invocation of the <strong>iterator</strong>&#x2019;s <code>next</code> method gives us a  <code>Promise</code>, we can devise a way to make the resolution of each <code>Promise</code> trigger the <code>next</code> method, resuming the code inside the <strong>generator</strong> where we left off and giving us access to the next Promise.</p>
<pre><code class="language-javascript">var Promise = require(&apos;bluebird&apos;)
var saySomething = (what) =&gt; Promise.resolve(`hello, ${what}`).delay(1000)

function* generator() {
  var message = yield saySomething(&apos;dog&apos;)
  console.log(message)
  message = yield saySomething(&apos;cat&apos;)
  console.log(message)
}

function runGenerator(genFn) {
  var iterator = genFn()
  nextStep()

  function nextStep(response) {
    var step = iterator.next(response)
    var promise = step.value
    if (!step.done) {
      promise.then(resolution =&gt; {
        nextStep(resolution)
      })
    }
  }
}

runGenerator(generator)
// 1s: hello, dog
// 2s: hello, cat
</code></pre>
<p>By wrapping our <strong>generator function</strong> with the helper function <code>runGenerator</code>, we can leverage the ability to exit and re-enter the generator function to elegantly handle asynchronous code with a very straightforward syntax.</p>
<p>Our <code>runGenerator</code> helper first creates an <strong>iterator</strong> from our <strong>generator function</strong>, then creates and invokes a function called <code>nextStep</code>. The <code>nextStep</code> function&#x2019;s job is actually pretty simple, even though it looks complicated - First, call <code>next</code> on the iterator, passing in the appropriate response to be handed back to the <code>yield</code> (The first time we call <code>nextStep</code>, we don&#x2019;t pass anything in, since we don&#x2019;t yet have anything to give back to the generator). By calling <code>next</code> on the iterator, code is run inside the <strong>generator</strong> up to the first <code>yield</code> statement, and we receive back a <code>step</code> object with a <code>value</code> property that&#x2019;s the <strong>Promise</strong> returned by <code>saySomething</code>!</p>
<p>This is the key - by adding a <code>.then</code> method to this <strong>Promise</strong>, we can define the behavior for it to perform when it resolves. What we want to do is trigger <code>nextStep</code>, but this time call it with the value resolved by the <strong>Promise</strong> (<code>&apos;hello, dog&apos;</code>). This <code>resolution</code> is then passed into the <code>iterator.next</code> method, which assigns it to the left of the first <code>yield</code> statement and the code restarts inside the <strong>generator</strong> unil the next <code>yield</code> is reached!</p>
<p>Notice that we have to check to make sure our <code>step</code> object isn&#x2019;t done before trying to call <code>next</code> again.</p>
<p>Fortunately, <code>bluebird</code> offers a <code>coroutine</code> method for doing just this. In cases where aysnchronous code is too complex to be handled elegantly by normal <strong>Promise</strong>-based methods, <strong>generator functions</strong> invoked by a <strong>coroutine</strong> handler can offer a massive increase in code readability.</p>
<pre><code class="language-javascript">var Promise = require(&apos;bluebird&apos;)
var saySomething = (what) =&gt; Promise.resolve(`hello, ${what}`).delay(1000)

function* generator() {
  var message = yield saySomething(&apos;dog&apos;)
  console.log(message)
  message = yield saySomething(&apos;cat&apos;)
  console.log(message)
}

Promise.coroutine(generator)()
// 1s: hello, dog
// 2s: hello, cat
</code></pre>
<p><strong>Promises</strong> with <strong>generator functions</strong> offer an elegant solution to the problems caused by complex asynchronous code - We can write code in a way that looks and behaves very much like normal, easy-to-read synchronous code by leveraging the ability to enter and exit the execution flow inside of a <strong>generator</strong>.</p>
]]></content>
        <author>
            <name>Andy Coenen</name>
            <email>andrew.coenen@gmail.com</email>
            <uri>https://cannoneyed.github.io/about</uri>
        </author>
    </entry>
</feed>